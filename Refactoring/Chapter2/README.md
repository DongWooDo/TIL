# 리팩터링 원칙

## 2.1 리팩터링 원칙

- 리팩터링: [명사] 소프트웨어 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.

리팩터링이란 코드를 정리하는 작업이 아니라 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.

## 2.2 두개의 모자

- 기능추가 모자: 기존 코드는 절대 건들이지 않고 새 기능을 추가하기만 한다.
- 리팩터링 모자: 기능 추가는 절대로 하지 않고 오로지 코드 재구성에만 전념하고 놓친 테스트 케이스가 없다면 테스트 케이스도 변경하지 않는다. 부득이 인터페이스를 변경해할 때만 기존 테스트를 수정한다.

저자는 두 모자를 자주 바꿔쓴다. 기능 추가를 하다 보면 코드 구조를 바꿔야 수월해지겠다라고 판단될 때가 있기 때문이다.

## 2.3 리팩터링 하는 이유

- 리팩터링하면 소프트웨어 설계가 좋아진다.
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
- 리팩터링하면 버그를 쉽게 찾을 수 있다.
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.
  - 내부설계가 좋으면 새로운 기능을 추가할 지점, 어떻게 고칠 지 쉽게 찾을 수 있음
  - 모듈화가 잘 되어있으면 코드베이스 중 작은 일부만 이해하면 된다.
  - 위의 2가지 효과를 `설계 지구력 가설`이라고 저자는 말한다. 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 말한다.

## 2.4 언제 리팩터링해야 할까?

저자는 거의 한시간 간격으로 리팩터링을 한다. 그리고 돈 로버츠(Don Roberts)의 `3의 법칙`을 따른다.

1. 처음에는 그냥 한다.
2. 비슷한 일을 두번째로 하게 되면, 일단 게속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
  - 리팩터링하기 가장 좋은 시점은 코드베에스에 기능을 새로 추가하기 직전이다.
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
  - 코드의 의도가 더 명확하게 드러나도록 리팩터링해야한다.
- 쓰레기 줍기 리팩터링
  - 효율성을 위해 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 작은 단계로 쪼개서 하면 조금씩 몇달에 걸쳐 수정해도 코드가 깨지지 않는다.
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 프로그래밍 과정에 자연스럽게 녹이는 것이다.
  - 계획된 리팩터링은 최소한으로 줄여야 한다. 팀원 여럿이 달려들정도로 곪아갈 수 있기 때문이다.
  - 무조건 리팩터링 커밋을 따로 나누는 것이 좋은 건 아니다. 팀에 적합한 방식을 찾자.
  - 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 `수정`하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
- 오래 걸리는 리팩터링
  - 저자는 팀 전체가 리팩터링에 매달리는 데는 회의적이다.
  - 주어진 문제를 몇주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.
- 코드 리뷰에 리팩터링 활용하기
  - 코드 리뷰 시 다른 사람들의 아이디어를 수집할 수 있다.
  - 코드 리뷰시 리팩터링을 하면 개선안을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있다.
  - `짝 프로그래밍`을 하는 것이 리팩터링에 가장 좋은 방법이라고 저자는 말한다.
- 관리자에게 뭐라고 말해야 될까?
  - 리팩터링을 하면 소프트웨어를 빠르게 만드는데 아주 효과적이다.
  - 버그를 찾고 새 함수를 추가하기전에 리팩터링을 하는 것이 주어진 임무를 수행하는 가장 빠른 길임을 알아야 한다.
- 리팩터링하지 말아야 할 때
  - 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링을 해야 효과를 제대로 볼 수 있다.
  - 리팩터링하는 것보다 처음부터 새로 작성하는게 쉬울때도 리팩터링하지 않는다. 하지만 이 부분은 직접해봐야 알 수 있는 경우가 많다. 많은 경험과 뛰어난 판단력을 필요로 한다.

## 2.5 리팩터링 시 고려할 문제

- 새 기능 개발 속도 저하
  - 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
  - 리팩터링을 `클린 코드`나 `바람직한 엔지니어링 습관`처럼 도덕적인 이유를 정당화하지 마라. 리팩터링은 오로지 경제적인 이유로 하는 것이다.
- 코드 소유권
  - 코드 소유권을 작은 단위로 나눠서 관리하지 마라.
  - 저자는 코드의 소유권을 팀에 두고 팀원이라면 누가나 팀이 소유한 코드를 수정할 수 있게 하는 것을 추천한다.
- 브랜치
  - 저자는 CI(Continuous Integration), 또는 TBD(Trunk-Based Development)를 추천한다. 기능 브랜치 통합 주기를 짧게 가져간다는 것이다. CI에 따르면 모든 팀원이 하루에 최소 한번 마스터와 통합한다.
  - CI를 사용하면 머지의 복잡도를 낮추는 것도 좋지만 리팩터링과 궁합이 좋다. 켄트 벡이 CI + 리팩터링을 합쳐서 `XP(eXtreme Programming)`을 만든 이유이다.
- 테스팅
  - 리팩터링을 하기 위해선 자가 테스트 코드를 마련 해야 한다. 리팩터링 시 코드가 깨지는 지 확인도 가능하며 새 기능 추가도 훨씬 안전하게 가져갈 수 있기 때문이다.
  - 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 CI와도 밀접하게 연관된다. CI에 통합된 테스트는 XP의 권장사항이자 CD(Continuous Delivery)의 핵심이기도 하다.
- 레거시 코드
  - 레거시 시스템을 파악할 때 리팩터링이 큰 도움이 된다. 하지만 테스트 코드가 있을 때 이야기이다. 테스트 코드를 염두에 두고 설계를 한 시스템이 아니기 때문에 테스트 코드가 넣기가 매우 까다롭다. 테스트 코드가 없을 경우 저자의 조언은 `레거시 코드 활용 전략`의 지침을 따르면 된다고 한다. `프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다`가 주내용이다. 그리고 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이 좋다.
- 데이터베이스
  - 이해 안감.

## 2.6 리팩터링, 아키텍쳐, 애그니(YAGNI)

코딩 전에 아키텍처를 확정지으려고 할 때의 대표적인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것이다. 하지만 막상 해보면 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다. 저자가 추천하는 방법은 향후 변경에 유연하게 대처할 수 있는 `유연성 매커니즘(flexible mechanism)`을 소프트웨어에 심어두는 것이다. 다양한 시나리오를 생각해서 매개변수들을 생각나는대로 추가할 때 매개변수가 바로 유연성 매커니즘이다. 하지만 함수 내부 로직이 매우 복잡해질 수 있으므로 저자가 추천하는 방법은 `YAGNI(you aren't going to need it)` 방법이다. 부르는 방식은 다양한데 `간결한 설계(simple design)`, `점진적 설계(incremental design)`이라고도 한다. 그저 현재까지 파악한 요구 사항만을 해결하는 소프트웨어를 구축하고 진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍쳐도 그에 맞게 리팩터링해서 바꾸는 것이다. 하지만 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 매커니즘(매개변수)을 미리 추가한다. 이러한 경향은 `진화형 아키텍쳐`원칙이 발전하는 계기가 되었다.

## 2.7 리팩터링 소프트웨어 개발 프로세스

- 최초의 애자일 소프트웨어 방법론 중 하나로 등장한 `XP`가 도입되어졌는데 `지속적 통합(CI)`, `자가 테스트 코드`, `리팩터링`등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스이다. 그리고 `자가 테스트 코드`와 `리팩터링`을 묶어서 `테스트주도개발(Test-Driven-Development)`라고 한다.

- 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.

- `지속적 통합(CI)`을 적용하면 다른 사람들의 작업을 방해하지않고 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다.
  `자가 테스트 코드` 역시 지속적 통합의 핵심요소다.

- `테스트 코드`, `지속적 통합(CI)`, `리팩터링`이라는 세가지 기법은 서로 강력한 상승효과를 발휘한다.

- YAGNI로 인해 리팩터링을 더욱 쉽게 할 수 있다. 단순한 시스템일수록 변경하기가 훨씬 쉽기 때문이다.

## 2.8 리팩터링과 성능

- 대부분 성능 최적화를 하는 경우 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때도 많다.
- 대부분의 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.
- 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.
- 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다. 전체를 고르게 최적화할 때와 마찬가지 방법으로 그 부분들을 개선한다. 이렇게 하면 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은 노력으로 훨씬 큰 효과를 볼 수 있다.
- 리팩터링할때 처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다. 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다. 성능이 개선되지 않았다면 수정 내용을 되돌린다. 반복한다.
- 프로그램을 잘 리팩터링을 해놓으면 이런식의 최적화에 두가지 면에서 도움 된다.
  1. 성능 튜닝에 투입할 시간을 벌 수 있다. 리팩터링이 잘 되어있다면 기능 추가가 빨리 끝나서 성능에 집중할 수 있는 시간을 더 벌 수 있다.
  2. 리팩터링이 잘 되어있는 프로그램은 성능을 더 세밀하게 분석할 수 있다. 프로파일러가 지적해주는 코드의 범위가 더 좁아질 것이고, 그래서 튜닝하기가 더 쉬워진다.

## 2.9 리팩터링의 유래

## 2.10 리팩터링 자동화

## 2.11 더 알고 싶다면

- `리팩터링 워크북(인사이트, 2006)`: 윌리엄 웨이크(William C. Wake)가 쓴 리팩터링을 연습에 주력한 책
- `패턴을 활용한 리팩터링(인사이트, 2011)`: 조슈아 케리에프스카(Joshua Kerievsky)가 쓴 소프트웨어 패턴 분야에 지대한 영향을 준 `디자인 패턴`책에서 가장 핵심적인 패턴을 골라, 코드를 그 패턴대로 재구성하기 위해 리팩터링하는 방법을 다루는 책
- `리팩토링 데이터베이스(위키북스, 2007)`: 스캇 엠블러(Scott Ambler)와 프라모드 사달게(Pramod Sadalage)가 쓴 책
- `리팩토링 HTML(에이콘출판사, 2009)`: 엘리엇 러스티 해롤드(Elliotte Rusty Harold)가 쓴 책
- `레거시 코드활용 전략(에이콘출판사, 2018)`: 마이클 페더스(Michael Feathers)가 쓴 테스트 커버리지가 낮은 오래된 코드베이스를 리팩터링하는 방법을 다루는 책
- `Refactoring: Ruby Edition(Addition-Wesley, 2009)`: 제일 필즈(Jay Fields)와 셰인 하비(Shane Harvey)가 쓴 책
- https://github.com/WegraLee/Refactoring
- https://github.com/wickedwukong/martin-fowler-refactoring-2nd
