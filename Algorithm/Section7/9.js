// 결혼식

// 현수는 다음 달에 결혼을 합니다.
// 현수는 결혼식 피로연을 장소를 빌려 3일간 쉬지 않고 하려고 합니다.
// 피로연에 참석하는 친구들 N명의 참석하는 시간정보를 현수는 친구들에게 미리 요구했습니다. 각 친구들은 자신이 몇 시에 도착해서 몇 시에 떠날 것인지 현수에게 알려주었습니다.
// 현수는 이 정보를 바탕으로 피로연 장소에 동시에 존재하는 최대 인원수를 구하여 그 인원을 수용할 수 있는 장소를 빌리려고 합니다. 여러분이 현수를 도와주세요.
// 만약 한 친구가 오는 시간 13, 가는시간 15라면 이 친구는 13시 정각에 피로연 장에 존재하는 것이고 15시 정각에는 존재하지 않는다고 가정합니다.

// ▣ 입력설명
// 첫째 줄에 피로연에 참석할 인원수 N(5<=N<=100,000)이 주어집니다.
// 두 번째 줄부터 N줄에 걸쳐 각 인원의 오는 시간과 가는 시간이 주어집니다.
// 시간은 첫날 0시를 0으로 해서 마지막날 밤 12시를 72로 하는 타임라인으로 오는 시간과 가는 시간이 음이 아닌 정수로 표현됩니다.

// ▣ 출력설명
// 첫째 줄에 피로연장에 동시에 존재하는 최대 인원을 출력하세요.

// ▣ 입력예제 1 5
// 14 18
// 12 15
// 15 20
// 20 30
// 5 14

// ▣ 출력예제 1
// 2

// 푼 시간: 25분, GG

// 강의 풀이: 그림으로 그려보면 좀 쉽게 설명가능
// NOTE: 전형적인 그리디 문제(그리디란 매 선택이 그 순간에 대해서는 최적인 선택을 하는 것이다. 하지만 이게 무조건 최선의 해가 될 순 없다)
function solution(times) {
  let answer = Number.MIN_SAFE_INTEGER;
  let T_line = [];
  for (let x of times) {
    T_line.push([x[0], "s"]);
    T_line.push([x[1], "e"]);
  }
  console.log(T_line);
  // [
  //   [ 14, 's' ], [ 18, 'e' ],
  //   [ 12, 's' ], [ 15, 'e' ],
  //   [ 15, 's' ], [ 20, 'e' ],
  //   [ 20, 's' ], [ 30, 'e' ],
  //   [ 5, 's' ],  [ 14, 'e' ]
  // ]

  // NOTE: s,e의 순서를 보장하기 위해서 반드시 sort를 해줘야 한다.
  T_line.sort((a, b) => {
    if (a[0] === b[0]) return a[1].charCodeAt() - b[1].charCodeAt();
    else return a[0] - b[0];
  });
  console.log(T_line);
  // [
  //   [ 5, 's' ],  [ 12, 's' ],
  //   [ 14, 'e' ], [ 14, 's' ],
  //   [ 15, 'e' ], [ 15, 's' ],
  //   [ 18, 'e' ], [ 20, 'e' ],
  //   [ 20, 's' ], [ 30, 'e' ]
  // ]

  // NOTE: s면 +1, e면 -1을 한다
  let cnt = 0;
  for (let x of T_line) {
    if (x[1] === "s") cnt++;
    else cnt--;
    answer = Math.max(answer, cnt); // NOTE: 계속 answer와 비교해서 가장 큰값을 캐낸다
  }
  return answer;
}

let arr = [
  [14, 18],
  [12, 15],
  [15, 20],
  [20, 30],
  [5, 14],
];
console.log(solution(arr));
